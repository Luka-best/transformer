from abc import ABC

from collections import Counter
from typing import List, Optional, Set, Tuple

import torch

from .file_utils import add_start_docstrings
from .utils.logging import get_logger


logger = get_logger(__name__)



class Constraint(ABC):
    r"""Abstract base class for all constraints that can be applied during generation.
    It must define how the constraint can be satisfied.

    All classes that inherit Constraint must follow the requirement that
    
    ```
    completed = False
    while(not completed):
        _, completed = constraint.update(constraint.advance())
    ```
    
    will always terminate (halt). 
    
    """
    def advance(self):
        '''
        When called, returns the token that would take this constraint
        one step closer to being fulfilled.
        '''
        raise NotImplementedError(
            f"{self.__class__} is an abstract class. Only classes inheriting this class can be called."
        )

    def does_advance(self, token_id: int):
        """
        Reads in a token and returns whether it creates progress.
        """
        raise NotImplementedError(
            f"{self.__class__} is an abstract class. Only classes inheriting this class can be called."
        )

    def update(self, token_id: int):
        """
        Reads in a token and returns booleans that indicate the progress made by it.
        This function will update the state of this object unlikes `does_advance(self, token_id: int)`.

        This function assumes that token_id is sure to be generated. This isn't to test whether
        a certain token will advnace the progress; so we update the states accordingly
        if it's already been generated. This becomes important if token_id != desired token (refer to else statement in PhrasalConstraint)

        Args:
            token_id(`int`):
                The id of a newly generated token in the beam search.
        returns:
            stepped(`boolean`):
                Whether this constraint has become one step closer to being fulfuilled.
            completed(`stepped`):
                Whether this constraint has been completely fulfilled by this token being generated.
        """
        raise NotImplementedError(
            f"{self.__class__} is an abstract class. Only classes inheriting this class can be called."
        )

class TokenConstraint(Constraint):
    r"""
    [`Constraint`] enforcing that a specific token is generated.

    Args:
        token_id (`int`):
            The token that must be generated by the output.
    """
    def __init__(self, token_id: int):
        if not isinstance(token_id, int) or token_id < 0:
            raise ValueError(f"`token_id` has to be a positive integer, but is {token_id}")
        self.token_id = token_id
    
    def advance(self):
        return self.token_id
    
    def does_advance(self, token_id: int):
        return token_id == self.token_id

    def update(self, token_id: int):
        if not isinstance(token_id, int) or token_id < 0:
            raise ValueError(f"`token_id` has to be a positive integer, but is {token_id}")

        if self.does_advance(token_id):
           return True, True # stepped, completed 
        else:
            return False, False
    

class PhrasalConstraint(Constraint):
    r"""
    [`Constraint`] enforcing that an ordered sequence of tokens is generated.

    Args:
        token_ids (`torch.Tensor`):
            The sequence of tokens that must be generated by the output.
    """
    def __init__(self, token_ids: torch.Tensor):
        if not isinstance(token_ids, torch.Tensor):
            raise ValueError(f"`token_ids` has to be a tensor, but is {type(token_ids)}")
        self.token_ids = token_ids

        # the index of the currently fulfilled step
        self.seqlen = self.token_ids.size(0)
        self.fulfilled_idx = -1
        self.completed = False
    
    def advance(self):
        return self.token_ids[self.fulfilled_idx + 1]
    
    def does_advance(self, token_id):
        return token_id == self.token_ids[self.fulfilled_idx + 1]

    def update(self, token_id: int):
        
        stepped = False
        completed = False
        reset = False

        if self.does_advance(token_id):
            self.fulfilled_idx += 1
            stepped = True
            if self.fulfilled_idx == (self.seqlen - 1):
                completed = True
            self.completed = completed
        else:
            # failed to make progress.
            reset = True
            self.reset()

        return stepped, completed

    def reset(self):
        self.completed = False
        self.fulfilled_idx = 0

        
class ConstraintListState:
    def __init__(self, constraints: List[Constraint]):
        self.complete_constraints = []
        self.inprogress_constraint = None
        self.pending_constraints = constraints
    
    def advance(self):
        '''The list of tokens to generate such that we can make progress.

        Though we don't care which constraint is fulfilled first,
        if we are in the progress of fulfilling a constraint, that's the only one 
        we'll return.
        '''
        if self.inprogress_constraint is None:
            token_list = [
                constraint.advance() for constraint in self.pending_constraints
            ]
            
        else:
            token_list = [self.inprogress_constraint.advance()]
            
        return token_list


    def update(self, token_id: int):
        if self.inprogress_constraint is None:
            stepped, complete, reset = self.inprogress_constraint.update(token_id)
            if reset:
                self.pending_constraints.append(self.inprogress_constraint)
                self.inprogress_constraint = None
            if complete:
                self.complete_constraints.append(self.inprogress_constraint)
                self.inprogress_constraint = None
        else:
            for cidx, pending_constraint in enumerate(self.pending_constraints):
                if pending_constraint.does_advance(token_id):
                    stepped, complete, reset = pending_constraint.update(token_id)
                    if complete:
                        self.complete_constraints.append(pending_constraint)
                        
                    elif stepped:
                        self.inprogress_constraint = pending_constraint
                    
                    if complete or stepped:
                        self.pending_constraints = pending_constraints[:idx] + pending_constraints[idx+1:]
                        break
                    
                    