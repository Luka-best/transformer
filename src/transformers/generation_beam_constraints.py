from abc import ABC

from itertools import chain
from collections import Counter
from typing import List, Optional, Set, Tuple

import torch

from .file_utils import add_start_docstrings
from .utils.logging import get_logger


logger = get_logger(__name__)



class Constraint(ABC):
    r"""Abstract base class for all constraints that can be applied during generation.
    It must define how the constraint can be satisfied.

    All classes that inherit Constraint must follow the requirement that
    
    ```
    completed = False
    while(not completed):
        _, completed = constraint.update(constraint.advance())
    ```
    
    will always terminate (halt). 
    
    """
    def __init__(self):
        # test for the above condition
        counter = 0
        completed = False
        while not completed:
            advance = self.advance()
            _, completed = self.update(advance)
            counter += 1

            if counter > 10000:
                raise Exception("update() does not fulfill the constraint.")
         
        
    def advance(self):
        '''
        When called, returns the token that would take this constraint
        one step closer to being fulfilled.
        '''
        raise NotImplementedError(
            f"{self.__class__} is an abstract class. Only classes inheriting this class can be called."
        )

    def does_advance(self, token_id: int):
        """
        Reads in a token and returns whether it creates progress.
        """
        raise NotImplementedError(
            f"{self.__class__} is an abstract class. Only classes inheriting this class can be called."
        )

    def update(self, token_id: int):
        """
        Reads in a token and returns booleans that indicate the progress made by it.
        This function will update the state of this object unlikes `does_advance(self, token_id: int)`.

        This function assumes that token_id is sure to be generated. This isn't to test whether
        a certain token will advnace the progress; so we update the states accordingly
        if it's already been generated. This becomes important if token_id != desired token (refer to else statement in PhrasalConstraint)

        Args:
            token_id(`int`):
                The id of a newly generated token in the beam search.
        returns:
            stepped(`boolean`):
                Whether this constraint has become one step closer to being fulfuilled.
            completed(`stepped`):
                Whether this constraint has been completely fulfilled by this token being generated.
        """
        raise NotImplementedError(
            f"{self.__class__} is an abstract class. Only classes inheriting this class can be called."
        )

class TokenConstraint(Constraint):
    r"""
    [`Constraint`] enforcing that a specific token is generated.

    Args:
        token_id (`int`):
            The token that must be generated by the output.
    """
    def __init__(self, token_id: int):
        super(Constraint, self).__init__()
        if not isinstance(token_id, int) or token_id < 0:
            raise ValueError(f"`token_id` has to be a positive integer, but is {token_id}")
        self.token_id = token_id
    
    def copy(self):
        return TokenConstraint(self.token_id)

    def advance(self):
        return self.token_id
    
    def does_advance(self, token_id: int):
        return token_id == self.token_id

    def update(self, token_id: int):
        if not isinstance(token_id, int) or token_id < 0:
            raise ValueError(f"`token_id` has to be a positive integer, but is {token_id}")

        if self.does_advance(token_id):
           return True, True, True # stepped, completed, reset
        else:
            return False, False, False
    

class PhrasalConstraint(Constraint):
    r"""
    [`Constraint`] enforcing that an ordered sequence of tokens is generated.

    Args:
        token_ids (`torch.Tensor`):
            The sequence of tokens that must be generated by the output.
    """
    def __init__(self, token_ids: torch.Tensor):
        super(Constraint, self).__init__()
        if not isinstance(token_ids, torch.Tensor):
            raise ValueError(f"`token_ids` has to be a tensor, but is {type(token_ids)}")
        self.token_ids = token_ids

        
        self.seqlen = self.token_ids.size(0)
        self.fulfilled_idx = -1 # the index of the currently fulfilled step
        self.completed = False
    
    def copy(self):
        return PhrasalConstraint(self.token_ids)

    def advance(self):
        return self.token_ids[self.fulfilled_idx + 1]
    
    def does_advance(self, token_id):
        if self.completed:
            return False

        return token_id == self.token_ids[self.fulfilled_idx + 1]

    def update(self, token_id: int):
        stepped = False
        completed = False
        reset = False

        if self.does_advance(token_id):
            self.fulfilled_idx += 1
            stepped = True
            if self.fulfilled_idx == (self.seqlen - 1):
                completed = True
            self.completed = completed
        else:
            # failed to make progress.
            reset = True
            self.reset()
        return stepped, completed, reset

    def reset(self):
        self.completed = False
        self.fulfilled_idx = 0

        
class ConstraintListState:
    def __init__(self, constraints: List[Constraint]):
        self.constraints = constraints
        self.n_constraints = len(constraints)
        self.completed = False

        self.init_state()


    def init_state(self):
        self.complete_constraints = []
        self.inprogress_constraint = None
        self.pending_constraints = [constraint.copy() for constraint in self.constraints]
    
    def advance(self):
        '''The list of tokens to generate such that we can make progress.

        Though we don't care which constraint is fulfilled first,
        if we are in the progress of fulfilling a constraint, that's the only one 
        we'll return.
        '''
        if self.inprogress_constraint is None:
            print("RUN ADVANCE NO PROGRESS")
            print("self.pending_constraints", self.pending_constraints)
            token_list = []
            for constraint in self.pending_constraints:
                advance = constraint.advance()
                token_list.append(advance)
        else:
            token_list = [self.inprogress_constraint.advance()]
        
        if len(token_list) == 0:
            return None
        else:
            return torch.stack(token_list)

    def update(self, token_ids: torch.Tensor):
        '''
        token_ids: the tokens generated thus far to reset the state of the
        progress through constraints.
        '''
        self.init_state()
        print("\n!!!START UPDATE\n\n")
        for token in token_ids:
            print("token", token)
            complete, stepped = self.add(token)
            print("complete, stepped", complete, stepped)

        return self
        

    def add(self, token_id: int):
        if self.completed:
            return

        complete, stepped = False, False
        if self.inprogress_constraint is not None:
            '''
            In the middle of fulfilling a constraint. 

            If the token just steps (make but an incremental progress to current job) it, do nothing.
            '''
            stepped, complete, reset = self.inprogress_constraint.update(token_id)
            if reset:
                '''
                1. If the next token breaks the fulfillment, then we must restart.
                    e.g. force the sequence "I love pies" and the next token after "I love" is "books".
                '''
                print("RESET")
                self.pending_constraints.append(self.inprogress_constraint.copy())
                self.inprogress_constraint = None                
                print("self.pending_constraints", self.pending_constraints)

            if complete:
                '''
                2. If the next token completes the constraint, move it to completed list, set 
                    inprogress to None. If there are no pending constraints either, then this
                    full list of constraints is complete.
                '''
                self.complete_constraints.append(self.inprogress_constraint)
                self.inprogress_constraint = None

                if len(self.pending_constraints) == 0:
                    self.completed = True
        else:
            '''
            Not in the middle of fulfilling a constraint. 
            '''
            print("NOT IN THE MIDDLE", self.pending_constraints)
            for cidx, pending_constraint in enumerate(self.pending_constraints):
                '''
                1. Does it advance any of the pending constraints?
                '''
                if pending_constraint.does_advance(token_id):
                    stepped, complete, reset = pending_constraint.update(token_id)
                    if complete:
                        self.complete_constraints.append(pending_constraint)
                        self.inprogress_constraint = None
                    if not complete and stepped:
                        self.inprogress_constraint = pending_constraint
                    
                    if complete or stepped:
                        self.pending_constraints = self.pending_constraints[:cidx] + self.pending_constraints[cidx+1:]
                        print("!!!self.pending_constraints", self.pending_constraints)
                        print()
                        if len(self.pending_constraints) == 0 and self.inprogress_constraint is None:
                            self.completed = True 

                        break

        return complete, stepped
        
                        
                    