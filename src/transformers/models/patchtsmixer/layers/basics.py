# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/108c_models.TSTPlus.ipynb (unless otherwise specified).

__all__ = ['Transpose', 'LinBnDrop', 'SigmoidRange', 'sigmoid_range', 'get_activation_fn']
           

import torch
from torch import nn

class Transpose(nn.Module):
    def __init__(self, *dims, contiguous=False): 
        super().__init__()
        self.dims, self.contiguous = dims, contiguous
    def forward(self, x):        
        if self.contiguous: return x.transpose(*self.dims).contiguous()
        else: return x.transpose(*self.dims)


class SigmoidRange(nn.Module):
    def __init__(self, low, high):
        super().__init__()
        self.low, self.high = low, high   
        # self.low, self.high = ranges        
    def forward(self, x):                    
        # return sigmoid_range(x, self.low, self.high)
        return torch.sigmoid(x) * (self.high - self.low) + self.low


class LinBnDrop(nn.Sequential):
    "Module grouping `BatchNorm1d`, `Dropout` and `Linear` layers"
    def __init__(self, n_in, n_out, bn=True, p=0., act=None, lin_first=False):
        layers = [nn.BatchNorm2d(n_out if lin_first else n_in, ndim=1)] if bn else []
        if p != 0: layers.append(nn.Dropout(p))
        lin = [nn.Linear(n_in, n_out, bias=not bn)]
        if act is not None: lin.append(act)
        layers = lin+layers if lin_first else layers+lin
        super().__init__(*layers)


def sigmoid_range(x, low, high):
    "Sigmoid function with range `(low, high)`"
    return torch.sigmoid(x) * (high - low) + low

def get_activation_fn(activation):
    if callable(activation): return activation()
    elif activation.lower() == "relu": return nn.ReLU()
    elif activation.lower() == "gelu": return nn.GELU()
    raise ValueError(f'{activation} is not available. You can use "relu", "gelu", or a callable')



def check_forecast_masks(z, 
    forecast_len: int,
    patch_size: int,
    in_channels: int,
    cv_channel_indices: list,
    d_size:str,
    mask_value:int = 0):

    if (forecast_len%patch_size) == 0:
        forecast_patches = int(forecast_len/patch_size)
    else:
        raise Exception("forecast_len must be divisible by patch_size for this mode")

    if cv_channel_indices is None:
        channels_to_mask = list(range(in_channels))
    else:
        channels_to_mask = list(set(range(in_channels)) - set(cv_channel_indices))
    
    if d_size == "4D":
        if not (z[:,channels_to_mask,-forecast_patches:,:] == mask_value).all():
            raise Exception("There are non-zero values in forcast masked points. Possibilty of data leaks")
    elif d_size == "6D":
        if not (z[:,:,:,channels_to_mask,-forecast_patches:,:] == mask_value).all():
            raise Exception("There are non-zero values in forcast masked points. Possibilty of data leaks")
    

def get_reindices_after_channel_filtering(in_channels: int,
    finetune_channel_indices: list,
    cv_channel_indices: list,
    forecast_channel_indices: list):

    if cv_channel_indices is None:
        cv_channel_indices = []
    
    if forecast_channel_indices is None or finetune_channel_indices is None:
        raise Exception("forecast_channel_indices/finetune_channel_indices cannot be None during reindices")
    
    if len(set(cv_channel_indices).intersection(set(forecast_channel_indices))) != 0:
        raise Exception("forecast_channel_indices and cv_channel_indices should be nonoverlapping. ")


    if finetune_channel_indices is not None: 
        finetune_channel_indices.sort()
    if cv_channel_indices is not None: 
        cv_channel_indices.sort()
    if forecast_channel_indices is not None: 
        forecast_channel_indices.sort()

    cv_channel_indices = list(set(cv_channel_indices).intersection(set(finetune_channel_indices)))

    if len(set(forecast_channel_indices)-set(finetune_channel_indices)) > 0:
        raise Exception("forecast_channel_indices should be subset of finetune_channel_indices")


    total_channels = list(range(in_channels))
    interest_channels = finetune_channel_indices
    remove_channels = list(set(total_channels) - set(interest_channels))
    
    new_indices = {}

    j = 0
    for i in total_channels:
        if i not in remove_channels:
            new_indices[i] = j
            j += 1
    
    new_cv_channel_indices = [new_indices[i] for i in cv_channel_indices]
    new_forecast_channel_indices = [new_indices[i] for i in forecast_channel_indices]
    new_in_channels = len(interest_channels)
    return new_in_channels, finetune_channel_indices, new_cv_channel_indices, new_forecast_channel_indices, new_indices




    